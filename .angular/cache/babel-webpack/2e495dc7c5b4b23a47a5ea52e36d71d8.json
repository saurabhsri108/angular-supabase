{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n\n    this._recoverSession();\n\n    this._recoverAndRefresh();\n\n    this._listenForMultiTabEvents();\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(({\n        error\n      }) => {\n        if (error) {\n          console.error('Error getting session from URL.', error);\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   */\n\n\n  signUp({\n    email,\n    password,\n    phone\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = phone && password ? yield this.api.signUpWithPhone(phone, password, {\n          data: options.data\n        }) : yield this.api.signUpWithEmail(email, password, {\n          redirectTo: options.redirectTo,\n          data: options.data\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on sign up.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  signIn({\n    email,\n    phone,\n    password,\n    refreshToken,\n    provider\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        if (email && !password) {\n          const {\n            error\n          } = yield this.api.sendMagicLinkEmail(email, {\n            redirectTo: options.redirectTo\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (email && password) {\n          return this._handleEmailSignIn(email, password, {\n            redirectTo: options.redirectTo\n          });\n        }\n\n        if (phone && !password) {\n          const {\n            error\n          } = yield this.api.sendMobileOTP(phone);\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (phone && password) {\n          return this._handlePhoneSignIn(phone, password);\n        }\n\n        if (refreshToken) {\n          // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n          const {\n            error\n          } = yield this._callRefreshToken(refreshToken);\n          if (error) throw error;\n          return {\n            user: this.currentUser,\n            session: this.currentSession,\n            error: null\n          };\n        }\n\n        if (provider) {\n          return this._handleProviderSignIn(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes\n          });\n        }\n\n        throw new Error(`You must provide either an email, phone number or a third-party provider.`);\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyOTP({\n    phone,\n    token\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = yield this.api.verifyMobileOTP(phone, token, options);\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n\n\n  user() {\n    return this.currentUser;\n  }\n  /**\n   * Returns the session data, if there is an active session.\n   */\n\n\n  session() {\n    return this.currentSession;\n  }\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n\n\n  refreshSession() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.'); // currentSession and currentUser will be updated to latest on _callRefreshToken\n\n        const {\n          error\n        } = yield this._callRefreshToken();\n        if (error) throw error;\n        return {\n          data: this.currentSession,\n          user: this.currentUser,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n\n\n  update(attributes) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n        const {\n          user,\n          error\n        } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n        if (error) throw error;\n        if (!user) throw Error('Invalid user data.');\n        const session = Object.assign(Object.assign({}, this.currentSession), {\n          user\n        });\n\n        this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED');\n\n        return {\n          data: user,\n          user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n\n\n  setSession(refresh_token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n\n        if (error) {\n          return {\n            session: null,\n            error: error\n          };\n        }\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e,\n          session: null\n        };\n      }\n    });\n  }\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n\n\n  setAuth(access_token) {\n    this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n      access_token,\n      token_type: 'bearer',\n      user: null\n    });\n    return this.currentSession;\n  }\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n\n\n  getSessionFromUrl(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new Error('No browser detected.');\n        const error_description = getParameterByName('error_description');\n        if (error_description) throw new Error(error_description);\n        const provider_token = getParameterByName('provider_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new Error('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new Error('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new Error('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new Error('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          user,\n          error\n        } = yield this.api.getUser(access_token);\n        if (error) throw error;\n        const session = {\n          provider_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user: user\n        };\n\n        if (options === null || options === void 0 ? void 0 : options.storeSession) {\n          this._saveSession(session);\n\n          const recoveryMode = getParameterByName('type');\n\n          this._notifyAllSubscribers('SIGNED_IN');\n\n          if (recoveryMode === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY');\n          }\n        } // Remove tokens from URL\n\n\n        window.location.hash = '';\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT');\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.api.signOut(accessToken);\n        if (error) return {\n          error\n        };\n      }\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n\n\n  onAuthStateChange(callback) {\n    try {\n      const id = uuid();\n      const subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: subscription,\n        error: null\n      };\n    } catch (e) {\n      return {\n        data: null,\n        error: e\n      };\n    }\n  }\n\n  _handleEmailSignIn(email, password, options = {}) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithEmail(email, password, {\n          redirectTo: options.redirectTo\n        });\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handlePhoneSignIn(phone, password) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithPhone(phone, password);\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handleProviderSignIn(provider, options = {}) {\n    const url = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes\n    });\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url;\n      }\n\n      return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n      return {\n        data: null,\n        user: null,\n        session: null,\n        error: e\n      };\n    }\n  }\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n\n\n  _recoverSession() {\n    var _a;\n\n    try {\n      const json = isBrowser() && ((_a = this.localStorage) === null || _a === void 0 ? void 0 : _a.getItem(STORAGE_KEY));\n\n      if (!json || typeof json !== 'string') {\n        return null;\n      }\n\n      const data = JSON.parse(json);\n      const {\n        currentSession,\n        expiresAt\n      } = data;\n      const timeNow = Math.round(Date.now() / 1000);\n\n      if (expiresAt >= timeNow && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n        this._saveSession(currentSession);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n      }\n    } catch (error) {\n      console.log('error', error);\n    }\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n\n\n  _recoverAndRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const json = isBrowser() && (yield this.localStorage.getItem(STORAGE_KEY));\n\n        if (!json) {\n          return null;\n        }\n\n        const data = JSON.parse(json);\n        const {\n          currentSession,\n          expiresAt\n        } = data;\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (expiresAt < timeNow) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n              yield this._removeSession();\n            }\n          } else {\n            this._removeSession();\n          }\n        } else if (!currentSession || !currentSession.user) {\n          console.log('Current session is missing data.');\n\n          this._removeSession();\n        } else {\n          // should be handled on _recoverSession method already\n          // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n          this._saveSession(currentSession);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (err) {\n        console.error(err);\n        return null;\n      }\n    });\n  }\n\n  _callRefreshToken(refresh_token) {\n    var _a;\n\n    if (refresh_token === void 0) {\n      refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n        if (error) throw error;\n        if (!data) throw Error('Invalid session data.');\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, this.currentSession));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n\n\n  _saveSession(session) {\n    this.currentSession = session;\n    this.currentUser = session.user;\n    const expiresAt = session.expires_at;\n\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000);\n      const expiresIn = expiresAt - timeNow;\n      const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5;\n\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n    } // Do we need any extra check before persist session\n    // access_token or user ?\n\n\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession);\n    }\n  }\n\n  _persistSession(currentSession) {\n    const data = {\n      currentSession,\n      expiresAt: currentSession.expires_at\n    };\n    isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentSession = null;\n      this.currentUser = null;\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      isBrowser() && (yield this.localStorage.removeItem(STORAGE_KEY));\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n\n\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n\n\n  _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      // console.debug('Auth multi-tab support is disabled.')\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('storage', e => {\n        var _a;\n\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue));\n\n          if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n            this._recoverAndRefresh();\n\n            this._notifyAllSubscribers('SIGNED_IN');\n          } else {\n            this._removeSession();\n\n            this._notifyAllSubscribers('SIGNED_OUT');\n          }\n        }\n      });\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/saurabhsrivastava/projects/angular-projects/angular-supabase/node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","GoTrueApi","isBrowser","getParameterByName","uuid","GOTRUE_URL","DEFAULT_HEADERS","STORAGE_KEY","polyfillGlobalThis","DEFAULT_OPTIONS","url","autoRefreshToken","persistSession","detectSessionInUrl","multiTab","headers","GoTrueClient","constructor","options","stateChangeEmitters","Map","settings","Object","assign","currentUser","currentSession","localStorage","globalThis","api","cookieOptions","fetch","_recoverSession","_recoverAndRefresh","_listenForMultiTabEvents","getSessionFromUrl","storeSession","error","console","signUp","email","password","phone","_removeSession","data","signUpWithPhone","signUpWithEmail","redirectTo","session","user","access_token","_saveSession","_notifyAllSubscribers","id","signIn","refreshToken","provider","sendMagicLinkEmail","_handleEmailSignIn","sendMobileOTP","_handlePhoneSignIn","_callRefreshToken","_handleProviderSignIn","scopes","Error","verifyOTP","token","verifyMobileOTP","refreshSession","_a","update","attributes","updateUser","setSession","refresh_token","refreshAccessToken","setAuth","token_type","error_description","provider_token","expires_in","timeNow","Math","round","Date","now","expires_at","parseInt","getUser","recoveryMode","window","location","hash","signOut","accessToken","onAuthStateChange","callback","subscription","unsubscribe","delete","set","_b","signInWithEmail","confirmed_at","email_confirmed_at","signInWithPhone","phone_confirmed_at","getUrlForProvider","href","json","getItem","JSON","parse","expiresAt","log","message","err","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","setItem","stringify","refreshTokenTimer","clearTimeout","removeItem","setTimeout","unref","addEventListener","key","newSession","String","newValue"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAASC,KAAT,CAAeC,KAAf,EAAsB;AAAE,WAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;AAAEA,MAAAA,OAAO,CAACD,KAAD,CAAP;AAAiB,KAA5C,CAApC;AAAoF;;AAC5G,SAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBJ,KAAnB,EAA0B;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBR,KAAlB,EAAyB;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;AAAsF;;AAC9GH,IAAAA,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CARD;;AASA,OAAOO,SAAP,MAAsB,aAAtB;AACA,SAASC,SAAT,EAAoBC,kBAApB,EAAwCC,IAAxC,QAAoD,eAApD;AACA,SAASC,UAAT,EAAqBC,eAArB,EAAsCC,WAAtC,QAAyD,iBAAzD;AACA,SAASC,kBAAT,QAAmC,iBAAnC;AACAA,kBAAkB,G,CAAI;;AACtB,MAAMC,eAAe,GAAG;AACpBC,EAAAA,GAAG,EAAEL,UADe;AAEpBM,EAAAA,gBAAgB,EAAE,IAFE;AAGpBC,EAAAA,cAAc,EAAE,IAHI;AAIpBC,EAAAA,kBAAkB,EAAE,IAJA;AAKpBC,EAAAA,QAAQ,EAAE,IALU;AAMpBC,EAAAA,OAAO,EAAET;AANW,CAAxB;AAQA,eAAe,MAAMU,YAAN,CAAmB;AAC9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,SAAKC,mBAAL,GAA2B,IAAIC,GAAJ,EAA3B;AACA,UAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBd,eAAlB,CAAd,EAAkDS,OAAlD,CAAjB;AACA,SAAKM,WAAL,GAAmB,IAAnB;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA,SAAKd,gBAAL,GAAwBU,QAAQ,CAACV,gBAAjC;AACA,SAAKC,cAAL,GAAsBS,QAAQ,CAACT,cAA/B;AACA,SAAKE,QAAL,GAAgBO,QAAQ,CAACP,QAAzB;AACA,SAAKY,YAAL,GAAoBL,QAAQ,CAACK,YAAT,IAAyBC,UAAU,CAACD,YAAxD;AACA,SAAKE,GAAL,GAAW,IAAI3B,SAAJ,CAAc;AACrBS,MAAAA,GAAG,EAAEW,QAAQ,CAACX,GADO;AAErBK,MAAAA,OAAO,EAAEM,QAAQ,CAACN,OAFG;AAGrBc,MAAAA,aAAa,EAAER,QAAQ,CAACQ,aAHH;AAIrBC,MAAAA,KAAK,EAAET,QAAQ,CAACS;AAJK,KAAd,CAAX;;AAMA,SAAKC,eAAL;;AACA,SAAKC,kBAAL;;AACA,SAAKC,wBAAL;;AACA,QAAIZ,QAAQ,CAACR,kBAAT,IAA+BX,SAAS,EAAxC,IAA8C,CAAC,CAACC,kBAAkB,CAAC,cAAD,CAAtE,EAAwF;AACpF;AACA,WAAK+B,iBAAL,CAAuB;AAAEC,QAAAA,YAAY,EAAE;AAAhB,OAAvB,EAA+CpC,IAA/C,CAAoD,CAAC;AAAEqC,QAAAA;AAAF,OAAD,KAAe;AAC/D,YAAIA,KAAJ,EAAW;AACPC,UAAAA,OAAO,CAACD,KAAR,CAAc,iCAAd,EAAiDA,KAAjD;AACH;AACJ,OAJD;AAKH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,MAAM,CAAC;AAAEC,IAAAA,KAAF;AAASC,IAAAA,QAAT;AAAmBC,IAAAA;AAAnB,GAAD,EAA6BvB,OAAO,GAAG,EAAvC,EAA2C;AAC7C,WAAOpC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,aAAK4D,cAAL;;AACA,cAAM;AAAEC,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkBK,KAAK,IAAID,QAAT,GAClB,MAAM,KAAKZ,GAAL,CAASgB,eAAT,CAAyBH,KAAzB,EAAgCD,QAAhC,EAA0C;AAC9CG,UAAAA,IAAI,EAAEzB,OAAO,CAACyB;AADgC,SAA1C,CADY,GAIlB,MAAM,KAAKf,GAAL,CAASiB,eAAT,CAAyBN,KAAzB,EAAgCC,QAAhC,EAA0C;AAC9CM,UAAAA,UAAU,EAAE5B,OAAO,CAAC4B,UAD0B;AAE9CH,UAAAA,IAAI,EAAEzB,OAAO,CAACyB;AAFgC,SAA1C,CAJZ;;AAQA,YAAIP,KAAJ,EAAW;AACP,gBAAMA,KAAN;AACH;;AACD,YAAI,CAACO,IAAL,EAAW;AACP,gBAAM,+BAAN;AACH;;AACD,YAAII,OAAO,GAAG,IAAd;AACA,YAAIC,IAAI,GAAG,IAAX;;AACA,YAAIL,IAAI,CAACM,YAAT,EAAuB;AACnBF,UAAAA,OAAO,GAAGJ,IAAV;AACAK,UAAAA,IAAI,GAAGD,OAAO,CAACC,IAAf;;AACA,eAAKE,YAAL,CAAkBH,OAAlB;;AACA,eAAKI,qBAAL,CAA2B,WAA3B;AACH;;AACD,YAAIR,IAAI,CAACS,EAAT,EAAa;AACTJ,UAAAA,IAAI,GAAGL,IAAP;AACH;;AACD,eAAO;AAAEK,UAAAA,IAAF;AAAQD,UAAAA,OAAR;AAAiBX,UAAAA,KAAK,EAAE;AAAxB,SAAP;AACH,OA5BD,CA6BA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEqD,UAAAA,IAAI,EAAE,IAAR;AAAcD,UAAAA,OAAO,EAAE,IAAvB;AAA6BX,UAAAA,KAAK,EAAEzC;AAApC,SAAP;AACH;AACJ,KAjCe,CAAhB;AAkCH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI0D,EAAAA,MAAM,CAAC;AAAEd,IAAAA,KAAF;AAASE,IAAAA,KAAT;AAAgBD,IAAAA,QAAhB;AAA0Bc,IAAAA,YAA1B;AAAwCC,IAAAA;AAAxC,GAAD,EAAqDrC,OAAO,GAAG,EAA/D,EAAmE;AACrE,WAAOpC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,aAAK4D,cAAL;;AACA,YAAIH,KAAK,IAAI,CAACC,QAAd,EAAwB;AACpB,gBAAM;AAAEJ,YAAAA;AAAF,cAAY,MAAM,KAAKR,GAAL,CAAS4B,kBAAT,CAA4BjB,KAA5B,EAAmC;AACvDO,YAAAA,UAAU,EAAE5B,OAAO,CAAC4B;AADmC,WAAnC,CAAxB;AAGA,iBAAO;AAAEE,YAAAA,IAAI,EAAE,IAAR;AAAcD,YAAAA,OAAO,EAAE,IAAvB;AAA6BX,YAAAA;AAA7B,WAAP;AACH;;AACD,YAAIG,KAAK,IAAIC,QAAb,EAAuB;AACnB,iBAAO,KAAKiB,kBAAL,CAAwBlB,KAAxB,EAA+BC,QAA/B,EAAyC;AAC5CM,YAAAA,UAAU,EAAE5B,OAAO,CAAC4B;AADwB,WAAzC,CAAP;AAGH;;AACD,YAAIL,KAAK,IAAI,CAACD,QAAd,EAAwB;AACpB,gBAAM;AAAEJ,YAAAA;AAAF,cAAY,MAAM,KAAKR,GAAL,CAAS8B,aAAT,CAAuBjB,KAAvB,CAAxB;AACA,iBAAO;AAAEO,YAAAA,IAAI,EAAE,IAAR;AAAcD,YAAAA,OAAO,EAAE,IAAvB;AAA6BX,YAAAA;AAA7B,WAAP;AACH;;AACD,YAAIK,KAAK,IAAID,QAAb,EAAuB;AACnB,iBAAO,KAAKmB,kBAAL,CAAwBlB,KAAxB,EAA+BD,QAA/B,CAAP;AACH;;AACD,YAAIc,YAAJ,EAAkB;AACd;AACA,gBAAM;AAAElB,YAAAA;AAAF,cAAY,MAAM,KAAKwB,iBAAL,CAAuBN,YAAvB,CAAxB;AACA,cAAIlB,KAAJ,EACI,MAAMA,KAAN;AACJ,iBAAO;AACHY,YAAAA,IAAI,EAAE,KAAKxB,WADR;AAEHuB,YAAAA,OAAO,EAAE,KAAKtB,cAFX;AAGHW,YAAAA,KAAK,EAAE;AAHJ,WAAP;AAKH;;AACD,YAAImB,QAAJ,EAAc;AACV,iBAAO,KAAKM,qBAAL,CAA2BN,QAA3B,EAAqC;AACxCT,YAAAA,UAAU,EAAE5B,OAAO,CAAC4B,UADoB;AAExCgB,YAAAA,MAAM,EAAE5C,OAAO,CAAC4C;AAFwB,WAArC,CAAP;AAIH;;AACD,cAAM,IAAIC,KAAJ,CAAW,2EAAX,CAAN;AACH,OAtCD,CAuCA,OAAOpE,CAAP,EAAU;AACN,eAAO;AAAEqD,UAAAA,IAAI,EAAE,IAAR;AAAcD,UAAAA,OAAO,EAAE,IAAvB;AAA6BX,UAAAA,KAAK,EAAEzC;AAApC,SAAP;AACH;AACJ,KA3Ce,CAAhB;AA4CH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIqE,EAAAA,SAAS,CAAC;AAAEvB,IAAAA,KAAF;AAASwB,IAAAA;AAAT,GAAD,EAAmB/C,OAAO,GAAG,EAA7B,EAAiC;AACtC,WAAOpC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,aAAK4D,cAAL;;AACA,cAAM;AAAEC,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKR,GAAL,CAASsC,eAAT,CAAyBzB,KAAzB,EAAgCwB,KAAhC,EAAuC/C,OAAvC,CAA9B;;AACA,YAAIkB,KAAJ,EAAW;AACP,gBAAMA,KAAN;AACH;;AACD,YAAI,CAACO,IAAL,EAAW;AACP,gBAAM,0CAAN;AACH;;AACD,YAAII,OAAO,GAAG,IAAd;AACA,YAAIC,IAAI,GAAG,IAAX;;AACA,YAAIL,IAAI,CAACM,YAAT,EAAuB;AACnBF,UAAAA,OAAO,GAAGJ,IAAV;AACAK,UAAAA,IAAI,GAAGD,OAAO,CAACC,IAAf;;AACA,eAAKE,YAAL,CAAkBH,OAAlB;;AACA,eAAKI,qBAAL,CAA2B,WAA3B;AACH;;AACD,YAAIR,IAAI,CAACS,EAAT,EAAa;AACTJ,UAAAA,IAAI,GAAGL,IAAP;AACH;;AACD,eAAO;AAAEK,UAAAA,IAAF;AAAQD,UAAAA,OAAR;AAAiBX,UAAAA,KAAK,EAAE;AAAxB,SAAP;AACH,OArBD,CAsBA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEqD,UAAAA,IAAI,EAAE,IAAR;AAAcD,UAAAA,OAAO,EAAE,IAAvB;AAA6BX,UAAAA,KAAK,EAAEzC;AAApC,SAAP;AACH;AACJ,KA1Be,CAAhB;AA2BH;AACD;AACJ;AACA;AACA;AACA;;;AACIqD,EAAAA,IAAI,GAAG;AACH,WAAO,KAAKxB,WAAZ;AACH;AACD;AACJ;AACA;;;AACIuB,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKtB,cAAZ;AACH;AACD;AACJ;AACA;;;AACI0C,EAAAA,cAAc,GAAG;AACb,QAAIC,EAAJ;;AACA,WAAOtF,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,EAAE,CAACsF,EAAE,GAAG,KAAK3C,cAAX,MAA+B,IAA/B,IAAuC2C,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACnB,YAArE,CAAJ,EACI,MAAM,IAAIc,KAAJ,CAAU,gBAAV,CAAN,CAFJ,CAGA;;AACA,cAAM;AAAE3B,UAAAA;AAAF,YAAY,MAAM,KAAKwB,iBAAL,EAAxB;AACA,YAAIxB,KAAJ,EACI,MAAMA,KAAN;AACJ,eAAO;AAAEO,UAAAA,IAAI,EAAE,KAAKlB,cAAb;AAA6BuB,UAAAA,IAAI,EAAE,KAAKxB,WAAxC;AAAqDY,UAAAA,KAAK,EAAE;AAA5D,SAAP;AACH,OARD,CASA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEgD,UAAAA,IAAI,EAAE,IAAR;AAAcK,UAAAA,IAAI,EAAE,IAApB;AAA0BZ,UAAAA,KAAK,EAAEzC;AAAjC,SAAP;AACH;AACJ,KAbe,CAAhB;AAcH;AACD;AACJ;AACA;;;AACI0E,EAAAA,MAAM,CAACC,UAAD,EAAa;AACf,QAAIF,EAAJ;;AACA,WAAOtF,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,EAAE,CAACsF,EAAE,GAAG,KAAK3C,cAAX,MAA+B,IAA/B,IAAuC2C,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACnB,YAArE,CAAJ,EACI,MAAM,IAAIc,KAAJ,CAAU,gBAAV,CAAN;AACJ,cAAM;AAAEf,UAAAA,IAAF;AAAQZ,UAAAA;AAAR,YAAkB,MAAM,KAAKR,GAAL,CAAS2C,UAAT,CAAoB,KAAK9C,cAAL,CAAoBwB,YAAxC,EAAsDqB,UAAtD,CAA9B;AACA,YAAIlC,KAAJ,EACI,MAAMA,KAAN;AACJ,YAAI,CAACY,IAAL,EACI,MAAMe,KAAK,CAAC,oBAAD,CAAX;AACJ,cAAMhB,OAAO,GAAGzB,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKE,cAAvB,CAAd,EAAsD;AAAEuB,UAAAA;AAAF,SAAtD,CAAhB;;AACA,aAAKE,YAAL,CAAkBH,OAAlB;;AACA,aAAKI,qBAAL,CAA2B,cAA3B;;AACA,eAAO;AAAER,UAAAA,IAAI,EAAEK,IAAR;AAAcA,UAAAA,IAAd;AAAoBZ,UAAAA,KAAK,EAAE;AAA3B,SAAP;AACH,OAZD,CAaA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEgD,UAAAA,IAAI,EAAE,IAAR;AAAcK,UAAAA,IAAI,EAAE,IAApB;AAA0BZ,UAAAA,KAAK,EAAEzC;AAAjC,SAAP;AACH;AACJ,KAjBe,CAAhB;AAkBH;AACD;AACJ;AACA;AACA;;;AACI6E,EAAAA,UAAU,CAACC,aAAD,EAAgB;AACtB,WAAO3F,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,CAAC2F,aAAL,EAAoB;AAChB,gBAAM,IAAIV,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACD,cAAM;AAAEpB,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKR,GAAL,CAAS8C,kBAAT,CAA4BD,aAA5B,CAA9B;;AACA,YAAIrC,KAAJ,EAAW;AACP,iBAAO;AAAEW,YAAAA,OAAO,EAAE,IAAX;AAAiBX,YAAAA,KAAK,EAAEA;AAAxB,WAAP;AACH;;AACD,aAAKc,YAAL,CAAkBP,IAAlB;;AACA,aAAKQ,qBAAL,CAA2B,WAA3B;;AACA,eAAO;AAAEJ,UAAAA,OAAO,EAAEJ,IAAX;AAAiBP,UAAAA,KAAK,EAAE;AAAxB,SAAP;AACH,OAXD,CAYA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEyC,UAAAA,KAAK,EAAEzC,CAAT;AAAYoD,UAAAA,OAAO,EAAE;AAArB,SAAP;AACH;AACJ,KAhBe,CAAhB;AAiBH;AACD;AACJ;AACA;AACA;;;AACI4B,EAAAA,OAAO,CAAC1B,YAAD,EAAe;AAClB,SAAKxB,cAAL,GAAsBH,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKE,cAAvB,CAAd,EAAsD;AAAEwB,MAAAA,YAAF;AAAgB2B,MAAAA,UAAU,EAAE,QAA5B;AAAsC5B,MAAAA,IAAI,EAAE;AAA5C,KAAtD,CAAtB;AACA,WAAO,KAAKvB,cAAZ;AACH;AACD;AACJ;AACA;AACA;;;AACIS,EAAAA,iBAAiB,CAAChB,OAAD,EAAU;AACvB,WAAOpC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,CAACoB,SAAS,EAAd,EACI,MAAM,IAAI6D,KAAJ,CAAU,sBAAV,CAAN;AACJ,cAAMc,iBAAiB,GAAG1E,kBAAkB,CAAC,mBAAD,CAA5C;AACA,YAAI0E,iBAAJ,EACI,MAAM,IAAId,KAAJ,CAAUc,iBAAV,CAAN;AACJ,cAAMC,cAAc,GAAG3E,kBAAkB,CAAC,gBAAD,CAAzC;AACA,cAAM8C,YAAY,GAAG9C,kBAAkB,CAAC,cAAD,CAAvC;AACA,YAAI,CAAC8C,YAAL,EACI,MAAM,IAAIc,KAAJ,CAAU,2BAAV,CAAN;AACJ,cAAMgB,UAAU,GAAG5E,kBAAkB,CAAC,YAAD,CAArC;AACA,YAAI,CAAC4E,UAAL,EACI,MAAM,IAAIhB,KAAJ,CAAU,yBAAV,CAAN;AACJ,cAAMU,aAAa,GAAGtE,kBAAkB,CAAC,eAAD,CAAxC;AACA,YAAI,CAACsE,aAAL,EACI,MAAM,IAAIV,KAAJ,CAAU,4BAAV,CAAN;AACJ,cAAMa,UAAU,GAAGzE,kBAAkB,CAAC,YAAD,CAArC;AACA,YAAI,CAACyE,UAAL,EACI,MAAM,IAAIb,KAAJ,CAAU,yBAAV,CAAN;AACJ,cAAMiB,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAhB;AACA,cAAMC,UAAU,GAAGL,OAAO,GAAGM,QAAQ,CAACP,UAAD,CAArC;AACA,cAAM;AAAE/B,UAAAA,IAAF;AAAQZ,UAAAA;AAAR,YAAkB,MAAM,KAAKR,GAAL,CAAS2D,OAAT,CAAiBtC,YAAjB,CAA9B;AACA,YAAIb,KAAJ,EACI,MAAMA,KAAN;AACJ,cAAMW,OAAO,GAAG;AACZ+B,UAAAA,cADY;AAEZ7B,UAAAA,YAFY;AAGZ8B,UAAAA,UAAU,EAAEO,QAAQ,CAACP,UAAD,CAHR;AAIZM,UAAAA,UAJY;AAKZZ,UAAAA,aALY;AAMZG,UAAAA,UANY;AAOZ5B,UAAAA,IAAI,EAAEA;AAPM,SAAhB;;AASA,YAAI9B,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACiB,YAA9D,EAA4E;AACxE,eAAKe,YAAL,CAAkBH,OAAlB;;AACA,gBAAMyC,YAAY,GAAGrF,kBAAkB,CAAC,MAAD,CAAvC;;AACA,eAAKgD,qBAAL,CAA2B,WAA3B;;AACA,cAAIqC,YAAY,KAAK,UAArB,EAAiC;AAC7B,iBAAKrC,qBAAL,CAA2B,mBAA3B;AACH;AACJ,SAxCD,CAyCA;;;AACAsC,QAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,EAAvB;AACA,eAAO;AAAEhD,UAAAA,IAAI,EAAEI,OAAR;AAAiBX,UAAAA,KAAK,EAAE;AAAxB,SAAP;AACH,OA5CD,CA6CA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEgD,UAAAA,IAAI,EAAE,IAAR;AAAcP,UAAAA,KAAK,EAAEzC;AAArB,SAAP;AACH;AACJ,KAjDe,CAAhB;AAkDH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIiG,EAAAA,OAAO,GAAG;AACN,QAAIxB,EAAJ;;AACA,WAAOtF,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAM+G,WAAW,GAAG,CAACzB,EAAE,GAAG,KAAK3C,cAAX,MAA+B,IAA/B,IAAuC2C,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACnB,YAAvF;;AACA,WAAKP,cAAL;;AACA,WAAKS,qBAAL,CAA2B,YAA3B;;AACA,UAAI0C,WAAJ,EAAiB;AACb,cAAM;AAAEzD,UAAAA;AAAF,YAAY,MAAM,KAAKR,GAAL,CAASgE,OAAT,CAAiBC,WAAjB,CAAxB;AACA,YAAIzD,KAAJ,EACI,OAAO;AAAEA,UAAAA;AAAF,SAAP;AACP;;AACD,aAAO;AAAEA,QAAAA,KAAK,EAAE;AAAT,OAAP;AACH,KAVe,CAAhB;AAWH;AACD;AACJ;AACA;AACA;;;AACI0D,EAAAA,iBAAiB,CAACC,QAAD,EAAW;AACxB,QAAI;AACA,YAAM3C,EAAE,GAAGhD,IAAI,EAAf;AACA,YAAM4F,YAAY,GAAG;AACjB5C,QAAAA,EADiB;AAEjB2C,QAAAA,QAFiB;AAGjBE,QAAAA,WAAW,EAAE,MAAM;AACf,eAAK9E,mBAAL,CAAyB+E,MAAzB,CAAgC9C,EAAhC;AACH;AALgB,OAArB;AAOA,WAAKjC,mBAAL,CAAyBgF,GAAzB,CAA6B/C,EAA7B,EAAiC4C,YAAjC;AACA,aAAO;AAAErD,QAAAA,IAAI,EAAEqD,YAAR;AAAsB5D,QAAAA,KAAK,EAAE;AAA7B,OAAP;AACH,KAXD,CAYA,OAAOzC,CAAP,EAAU;AACN,aAAO;AAAEgD,QAAAA,IAAI,EAAE,IAAR;AAAcP,QAAAA,KAAK,EAAEzC;AAArB,OAAP;AACH;AACJ;;AACD8D,EAAAA,kBAAkB,CAAClB,KAAD,EAAQC,QAAR,EAAkBtB,OAAO,GAAG,EAA5B,EAAgC;AAC9C,QAAIkD,EAAJ,EAAQgC,EAAR;;AACA,WAAOtH,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,cAAM;AAAE6D,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKR,GAAL,CAASyE,eAAT,CAAyB9D,KAAzB,EAAgCC,QAAhC,EAA0C;AACpEM,UAAAA,UAAU,EAAE5B,OAAO,CAAC4B;AADgD,SAA1C,CAA9B;AAGA,YAAIV,KAAK,IAAI,CAACO,IAAd,EACI,OAAO;AAAEA,UAAAA,IAAI,EAAE,IAAR;AAAcK,UAAAA,IAAI,EAAE,IAApB;AAA0BD,UAAAA,OAAO,EAAE,IAAnC;AAAyCX,UAAAA;AAAzC,SAAP;;AACJ,YAAI,CAAC,CAACgC,EAAE,GAAGzB,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACK,IAAvD,MAAiE,IAAjE,IAAyEoB,EAAE,KAAK,KAAK,CAArF,GAAyF,KAAK,CAA9F,GAAkGA,EAAE,CAACkC,YAAtG,MAAwH,CAACF,EAAE,GAAGzD,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACK,IAAvD,MAAiE,IAAjE,IAAyEoD,EAAE,KAAK,KAAK,CAArF,GAAyF,KAAK,CAA9F,GAAkGA,EAAE,CAACG,kBAA7N,CAAJ,EAAsP;AAClP,eAAKrD,YAAL,CAAkBP,IAAlB;;AACA,eAAKQ,qBAAL,CAA2B,WAA3B;AACH;;AACD,eAAO;AAAER,UAAAA,IAAF;AAAQK,UAAAA,IAAI,EAAEL,IAAI,CAACK,IAAnB;AAAyBD,UAAAA,OAAO,EAAEJ,IAAlC;AAAwCP,UAAAA,KAAK,EAAE;AAA/C,SAAP;AACH,OAXD,CAYA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEgD,UAAAA,IAAI,EAAE,IAAR;AAAcK,UAAAA,IAAI,EAAE,IAApB;AAA0BD,UAAAA,OAAO,EAAE,IAAnC;AAAyCX,UAAAA,KAAK,EAAEzC;AAAhD,SAAP;AACH;AACJ,KAhBe,CAAhB;AAiBH;;AACDgE,EAAAA,kBAAkB,CAAClB,KAAD,EAAQD,QAAR,EAAkB;AAChC,QAAI4B,EAAJ;;AACA,WAAOtF,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,cAAM;AAAE6D,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKR,GAAL,CAAS4E,eAAT,CAAyB/D,KAAzB,EAAgCD,QAAhC,CAA9B;AACA,YAAIJ,KAAK,IAAI,CAACO,IAAd,EACI,OAAO;AAAEA,UAAAA,IAAI,EAAE,IAAR;AAAcK,UAAAA,IAAI,EAAE,IAApB;AAA0BD,UAAAA,OAAO,EAAE,IAAnC;AAAyCX,UAAAA;AAAzC,SAAP;;AACJ,YAAI,CAACgC,EAAE,GAAGzB,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACK,IAAvD,MAAiE,IAAjE,IAAyEoB,EAAE,KAAK,KAAK,CAArF,GAAyF,KAAK,CAA9F,GAAkGA,EAAE,CAACqC,kBAAzG,EAA6H;AACzH,eAAKvD,YAAL,CAAkBP,IAAlB;;AACA,eAAKQ,qBAAL,CAA2B,WAA3B;AACH;;AACD,eAAO;AAAER,UAAAA,IAAF;AAAQK,UAAAA,IAAI,EAAEL,IAAI,CAACK,IAAnB;AAAyBD,UAAAA,OAAO,EAAEJ,IAAlC;AAAwCP,UAAAA,KAAK,EAAE;AAA/C,SAAP;AACH,OATD,CAUA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEgD,UAAAA,IAAI,EAAE,IAAR;AAAcK,UAAAA,IAAI,EAAE,IAApB;AAA0BD,UAAAA,OAAO,EAAE,IAAnC;AAAyCX,UAAAA,KAAK,EAAEzC;AAAhD,SAAP;AACH;AACJ,KAde,CAAhB;AAeH;;AACDkE,EAAAA,qBAAqB,CAACN,QAAD,EAAWrC,OAAO,GAAG,EAArB,EAAyB;AAC1C,UAAMR,GAAG,GAAG,KAAKkB,GAAL,CAAS8E,iBAAT,CAA2BnD,QAA3B,EAAqC;AAC7CT,MAAAA,UAAU,EAAE5B,OAAO,CAAC4B,UADyB;AAE7CgB,MAAAA,MAAM,EAAE5C,OAAO,CAAC4C;AAF6B,KAArC,CAAZ;;AAIA,QAAI;AACA;AACA,UAAI5D,SAAS,EAAb,EAAiB;AACbuF,QAAAA,MAAM,CAACC,QAAP,CAAgBiB,IAAhB,GAAuBjG,GAAvB;AACH;;AACD,aAAO;AAAE6C,QAAAA,QAAF;AAAY7C,QAAAA,GAAZ;AAAiBiC,QAAAA,IAAI,EAAE,IAAvB;AAA6BI,QAAAA,OAAO,EAAE,IAAtC;AAA4CC,QAAAA,IAAI,EAAE,IAAlD;AAAwDZ,QAAAA,KAAK,EAAE;AAA/D,OAAP;AACH,KAND,CAOA,OAAOzC,CAAP,EAAU;AACN;AACA,UAAIe,GAAJ,EACI,OAAO;AAAE6C,QAAAA,QAAF;AAAY7C,QAAAA,GAAZ;AAAiBiC,QAAAA,IAAI,EAAE,IAAvB;AAA6BI,QAAAA,OAAO,EAAE,IAAtC;AAA4CC,QAAAA,IAAI,EAAE,IAAlD;AAAwDZ,QAAAA,KAAK,EAAE;AAA/D,OAAP;AACJ,aAAO;AAAEO,QAAAA,IAAI,EAAE,IAAR;AAAcK,QAAAA,IAAI,EAAE,IAApB;AAA0BD,QAAAA,OAAO,EAAE,IAAnC;AAAyCX,QAAAA,KAAK,EAAEzC;AAAhD,OAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIoC,EAAAA,eAAe,GAAG;AACd,QAAIqC,EAAJ;;AACA,QAAI;AACA,YAAMwC,IAAI,GAAG1G,SAAS,OAAO,CAACkE,EAAE,GAAG,KAAK1C,YAAX,MAA6B,IAA7B,IAAqC0C,EAAE,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,EAAE,CAACyC,OAAH,CAAWtG,WAAX,CAArE,CAAtB;;AACA,UAAI,CAACqG,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EAAuC;AACnC,eAAO,IAAP;AACH;;AACD,YAAMjE,IAAI,GAAGmE,IAAI,CAACC,KAAL,CAAWH,IAAX,CAAb;AACA,YAAM;AAAEnF,QAAAA,cAAF;AAAkBuF,QAAAA;AAAlB,UAAgCrE,IAAtC;AACA,YAAMqC,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAhB;;AACA,UAAI4B,SAAS,IAAIhC,OAAb,KAAyBvD,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACuB,IAAxG,CAAJ,EAAmH;AAC/G,aAAKE,YAAL,CAAkBzB,cAAlB;;AACA,aAAK0B,qBAAL,CAA2B,WAA3B;AACH;AACJ,KAZD,CAaA,OAAOf,KAAP,EAAc;AACVC,MAAAA,OAAO,CAAC4E,GAAR,CAAY,OAAZ,EAAqB7E,KAArB;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIJ,EAAAA,kBAAkB,GAAG;AACjB,WAAOlD,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,cAAM8H,IAAI,GAAG1G,SAAS,OAAO,MAAM,KAAKwB,YAAL,CAAkBmF,OAAlB,CAA0BtG,WAA1B,CAAb,CAAtB;;AACA,YAAI,CAACqG,IAAL,EAAW;AACP,iBAAO,IAAP;AACH;;AACD,cAAMjE,IAAI,GAAGmE,IAAI,CAACC,KAAL,CAAWH,IAAX,CAAb;AACA,cAAM;AAAEnF,UAAAA,cAAF;AAAkBuF,UAAAA;AAAlB,YAAgCrE,IAAtC;AACA,cAAMqC,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAhB;;AACA,YAAI4B,SAAS,GAAGhC,OAAhB,EAAyB;AACrB,cAAI,KAAKrE,gBAAL,IAAyBc,cAAc,CAACgD,aAA5C,EAA2D;AACvD,kBAAM;AAAErC,cAAAA;AAAF,gBAAY,MAAM,KAAKwB,iBAAL,CAAuBnC,cAAc,CAACgD,aAAtC,CAAxB;;AACA,gBAAIrC,KAAJ,EAAW;AACPC,cAAAA,OAAO,CAAC4E,GAAR,CAAY7E,KAAK,CAAC8E,OAAlB;AACA,oBAAM,KAAKxE,cAAL,EAAN;AACH;AACJ,WAND,MAOK;AACD,iBAAKA,cAAL;AACH;AACJ,SAXD,MAYK,IAAI,CAACjB,cAAD,IAAmB,CAACA,cAAc,CAACuB,IAAvC,EAA6C;AAC9CX,UAAAA,OAAO,CAAC4E,GAAR,CAAY,kCAAZ;;AACA,eAAKvE,cAAL;AACH,SAHI,MAIA;AACD;AACA;AACA,eAAKQ,YAAL,CAAkBzB,cAAlB;;AACA,eAAK0B,qBAAL,CAA2B,WAA3B;AACH;AACJ,OA9BD,CA+BA,OAAOgE,GAAP,EAAY;AACR9E,QAAAA,OAAO,CAACD,KAAR,CAAc+E,GAAd;AACA,eAAO,IAAP;AACH;AACJ,KApCe,CAAhB;AAqCH;;AACDvD,EAAAA,iBAAiB,CAACa,aAAD,EAAgB;AAC7B,QAAIL,EAAJ;;AACA,QAAIK,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,MAAAA,aAAa,GAAG,CAACL,EAAE,GAAG,KAAK3C,cAAX,MAA+B,IAA/B,IAAuC2C,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACK,aAAnF;AAAmG;;AACnI,WAAO3F,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,CAAC2F,aAAL,EAAoB;AAChB,gBAAM,IAAIV,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACD,cAAM;AAAEpB,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKR,GAAL,CAAS8C,kBAAT,CAA4BD,aAA5B,CAA9B;AACA,YAAIrC,KAAJ,EACI,MAAMA,KAAN;AACJ,YAAI,CAACO,IAAL,EACI,MAAMoB,KAAK,CAAC,uBAAD,CAAX;;AACJ,aAAKb,YAAL,CAAkBP,IAAlB;;AACA,aAAKQ,qBAAL,CAA2B,iBAA3B;;AACA,aAAKA,qBAAL,CAA2B,WAA3B;;AACA,eAAO;AAAER,UAAAA,IAAF;AAAQP,UAAAA,KAAK,EAAE;AAAf,SAAP;AACH,OAbD,CAcA,OAAOzC,CAAP,EAAU;AACN,eAAO;AAAEgD,UAAAA,IAAI,EAAE,IAAR;AAAcP,UAAAA,KAAK,EAAEzC;AAArB,SAAP;AACH;AACJ,KAlBe,CAAhB;AAmBH;;AACDwD,EAAAA,qBAAqB,CAACiE,KAAD,EAAQ;AACzB,SAAKjG,mBAAL,CAAyBkG,OAAzB,CAAkCC,CAAD,IAAOA,CAAC,CAACvB,QAAF,CAAWqB,KAAX,EAAkB,KAAK3F,cAAvB,CAAxC;AACH;AACD;AACJ;AACA;AACA;;;AACIyB,EAAAA,YAAY,CAACH,OAAD,EAAU;AAClB,SAAKtB,cAAL,GAAsBsB,OAAtB;AACA,SAAKvB,WAAL,GAAmBuB,OAAO,CAACC,IAA3B;AACA,UAAMgE,SAAS,GAAGjE,OAAO,CAACsC,UAA1B;;AACA,QAAI2B,SAAJ,EAAe;AACX,YAAMhC,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAhB;AACA,YAAMmC,SAAS,GAAGP,SAAS,GAAGhC,OAA9B;AACA,YAAMwC,4BAA4B,GAAGD,SAAS,GAAG,EAAZ,GAAiB,EAAjB,GAAsB,GAA3D;;AACA,WAAKE,sBAAL,CAA4B,CAACF,SAAS,GAAGC,4BAAb,IAA6C,IAAzE;AACH,KATiB,CAUlB;AACA;;;AACA,QAAI,KAAK5G,cAAL,IAAuBmC,OAAO,CAACsC,UAAnC,EAA+C;AAC3C,WAAKqC,eAAL,CAAqB,KAAKjG,cAA1B;AACH;AACJ;;AACDiG,EAAAA,eAAe,CAACjG,cAAD,EAAiB;AAC5B,UAAMkB,IAAI,GAAG;AAAElB,MAAAA,cAAF;AAAkBuF,MAAAA,SAAS,EAAEvF,cAAc,CAAC4D;AAA5C,KAAb;AACAnF,IAAAA,SAAS,MAAM,KAAKwB,YAAL,CAAkBiG,OAAlB,CAA0BpH,WAA1B,EAAuCuG,IAAI,CAACc,SAAL,CAAejF,IAAf,CAAvC,CAAf;AACH;;AACDD,EAAAA,cAAc,GAAG;AACb,WAAO5D,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,WAAK2C,cAAL,GAAsB,IAAtB;AACA,WAAKD,WAAL,GAAmB,IAAnB;AACA,UAAI,KAAKqG,iBAAT,EACIC,YAAY,CAAC,KAAKD,iBAAN,CAAZ;AACJ3H,MAAAA,SAAS,OAAO,MAAM,KAAKwB,YAAL,CAAkBqG,UAAlB,CAA6BxH,WAA7B,CAAb,CAAT;AACH,KANe,CAAhB;AAOH;AACD;AACJ;AACA;AACA;;;AACIkH,EAAAA,sBAAsB,CAACrI,KAAD,EAAQ;AAC1B,QAAI,KAAKyI,iBAAT,EACIC,YAAY,CAAC,KAAKD,iBAAN,CAAZ;AACJ,QAAIzI,KAAK,IAAI,CAAT,IAAc,CAAC,KAAKuB,gBAAxB,EACI;AACJ,SAAKkH,iBAAL,GAAyBG,UAAU,CAAC,MAAM,KAAKpE,iBAAL,EAAP,EAAiCxE,KAAjC,CAAnC;AACA,QAAI,OAAO,KAAKyI,iBAAL,CAAuBI,KAA9B,KAAwC,UAA5C,EACI,KAAKJ,iBAAL,CAAuBI,KAAvB;AACP;AACD;AACJ;AACA;;;AACIhG,EAAAA,wBAAwB,GAAG;AACvB,QAAI,CAAC,KAAKnB,QAAN,IAAkB,CAACZ,SAAS,EAA5B,IAAkC,EAAEuF,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACyC,gBAAzD,CAAtC,EAAkH;AAC9G;AACA,aAAO,KAAP;AACH;;AACD,QAAI;AACAzC,MAAAA,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACyC,gBAAP,CAAwB,SAAxB,EAAoCvI,CAAD,IAAO;AACtF,YAAIyE,EAAJ;;AACA,YAAIzE,CAAC,CAACwI,GAAF,KAAU5H,WAAd,EAA2B;AACvB,gBAAM6H,UAAU,GAAGtB,IAAI,CAACC,KAAL,CAAWsB,MAAM,CAAC1I,CAAC,CAAC2I,QAAH,CAAjB,CAAnB;;AACA,cAAI,CAAClE,EAAE,GAAGgE,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAAC3G,cAAzE,MAA6F,IAA7F,IAAqG2C,EAAE,KAAK,KAAK,CAAjH,GAAqH,KAAK,CAA1H,GAA8HA,EAAE,CAACnB,YAArI,EAAmJ;AAC/I,iBAAKjB,kBAAL;;AACA,iBAAKmB,qBAAL,CAA2B,WAA3B;AACH,WAHD,MAIK;AACD,iBAAKT,cAAL;;AACA,iBAAKS,qBAAL,CAA2B,YAA3B;AACH;AACJ;AACJ,OAb+C,CAAhD;AAcH,KAfD,CAgBA,OAAOf,KAAP,EAAc;AACVC,MAAAA,OAAO,CAACD,KAAR,CAAc,0BAAd,EAA0CA,KAA1C;AACH;AACJ;;AAxkB6B","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: DEFAULT_HEADERS,\n};\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param options.url The URL of the GoTrue server.\n     * @param options.headers Any additional headers to send to the GoTrue server.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.cookieOptions\n     * @param options.fetch A custom fetch implementation.\n     */\n    constructor(options) {\n        this.stateChangeEmitters = new Map();\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.currentUser = null;\n        this.currentSession = null;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.multiTab = settings.multiTab;\n        this.localStorage = settings.localStorage || globalThis.localStorage;\n        this.api = new GoTrueApi({\n            url: settings.url,\n            headers: settings.headers,\n            cookieOptions: settings.cookieOptions,\n            fetch: settings.fetch,\n        });\n        this._recoverSession();\n        this._recoverAndRefresh();\n        this._listenForMultiTabEvents();\n        if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n            // Handle the OAuth redirect\n            this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n                if (error) {\n                    console.error('Error getting session from URL.', error);\n                }\n            });\n        }\n    }\n    /**\n     * Creates a new user.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param phone The user's phone number.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata.\n     */\n    signUp({ email, password, phone }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = phone && password\n                    ? yield this.api.signUpWithPhone(phone, password, {\n                        data: options.data,\n                    })\n                    : yield this.api.signUpWithEmail(email, password, {\n                        redirectTo: options.redirectTo,\n                        data: options.data,\n                    });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on sign up.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    signIn({ email, phone, password, refreshToken, provider }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                if (email && !password) {\n                    const { error } = yield this.api.sendMagicLinkEmail(email, {\n                        redirectTo: options.redirectTo,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (email && password) {\n                    return this._handleEmailSignIn(email, password, {\n                        redirectTo: options.redirectTo,\n                    });\n                }\n                if (phone && !password) {\n                    const { error } = yield this.api.sendMobileOTP(phone);\n                    return { user: null, session: null, error };\n                }\n                if (phone && password) {\n                    return this._handlePhoneSignIn(phone, password);\n                }\n                if (refreshToken) {\n                    // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n                    const { error } = yield this._callRefreshToken(refreshToken);\n                    if (error)\n                        throw error;\n                    return {\n                        user: this.currentUser,\n                        session: this.currentSession,\n                        error: null,\n                    };\n                }\n                if (provider) {\n                    return this._handleProviderSignIn(provider, {\n                        redirectTo: options.redirectTo,\n                        scopes: options.scopes,\n                    });\n                }\n                throw new Error(`You must provide either an email, phone number or a third-party provider.`);\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP({ phone, token }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = yield this.api.verifyMobileOTP(phone, token, options);\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on token verification.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n    user() {\n        return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n    session() {\n        return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n    refreshSession() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                // currentSession and currentUser will be updated to latest on _callRefreshToken\n                const { error } = yield this._callRefreshToken();\n                if (error)\n                    throw error;\n                return { data: this.currentSession, user: this.currentUser, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n    update(attributes) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                const { user, error } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n                if (error)\n                    throw error;\n                if (!user)\n                    throw Error('Invalid user data.');\n                const session = Object.assign(Object.assign({}, this.currentSession), { user });\n                this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED');\n                return { data: user, user, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sets the session data from refresh_token and returns current Session and Error\n     * @param refresh_token a JWT token\n     */\n    setSession(refresh_token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error) {\n                    return { session: null, error: error };\n                }\n                this._saveSession(data);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { session: data, error: null };\n            }\n            catch (e) {\n                return { error: e, session: null };\n            }\n        });\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n    setAuth(access_token) {\n        this.currentSession = Object.assign(Object.assign({}, this.currentSession), { access_token, token_type: 'bearer', user: null });\n        return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n    getSessionFromUrl(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new Error('No browser detected.');\n                const error_description = getParameterByName('error_description');\n                if (error_description)\n                    throw new Error(error_description);\n                const provider_token = getParameterByName('provider_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new Error('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new Error('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new Error('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new Error('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { user, error } = yield this.api.getUser(access_token);\n                if (error)\n                    throw error;\n                const session = {\n                    provider_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user: user,\n                };\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                    this._saveSession(session);\n                    const recoveryMode = getParameterByName('type');\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    if (recoveryMode === 'recovery') {\n                        this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                    }\n                }\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n            this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT');\n            if (accessToken) {\n                const { error } = yield this.api.signOut(accessToken);\n                if (error)\n                    return { error };\n            }\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n    onAuthStateChange(callback) {\n        try {\n            const id = uuid();\n            const subscription = {\n                id,\n                callback,\n                unsubscribe: () => {\n                    this.stateChangeEmitters.delete(id);\n                },\n            };\n            this.stateChangeEmitters.set(id, subscription);\n            return { data: subscription, error: null };\n        }\n        catch (e) {\n            return { data: null, error: e };\n        }\n    }\n    _handleEmailSignIn(email, password, options = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithEmail(email, password, {\n                    redirectTo: options.redirectTo,\n                });\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handlePhoneSignIn(phone, password) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithPhone(phone, password);\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this.api.getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n        });\n        try {\n            // try to open on the browser\n            if (isBrowser()) {\n                window.location.href = url;\n            }\n            return { provider, url, data: null, session: null, user: null, error: null };\n        }\n        catch (e) {\n            // fallback to returning the URL\n            if (url)\n                return { provider, url, data: null, session: null, user: null, error: null };\n            return { data: null, user: null, session: null, error: e };\n        }\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n    _recoverSession() {\n        var _a;\n        try {\n            const json = isBrowser() && ((_a = this.localStorage) === null || _a === void 0 ? void 0 : _a.getItem(STORAGE_KEY));\n            if (!json || typeof json !== 'string') {\n                return null;\n            }\n            const data = JSON.parse(json);\n            const { currentSession, expiresAt } = data;\n            const timeNow = Math.round(Date.now() / 1000);\n            if (expiresAt >= timeNow && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n                this._saveSession(currentSession);\n                this._notifyAllSubscribers('SIGNED_IN');\n            }\n        }\n        catch (error) {\n            console.log('error', error);\n        }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const json = isBrowser() && (yield this.localStorage.getItem(STORAGE_KEY));\n                if (!json) {\n                    return null;\n                }\n                const data = JSON.parse(json);\n                const { currentSession, expiresAt } = data;\n                const timeNow = Math.round(Date.now() / 1000);\n                if (expiresAt < timeNow) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            yield this._removeSession();\n                        }\n                    }\n                    else {\n                        this._removeSession();\n                    }\n                }\n                else if (!currentSession || !currentSession.user) {\n                    console.log('Current session is missing data.');\n                    this._removeSession();\n                }\n                else {\n                    // should be handled on _recoverSession method already\n                    // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                    this._saveSession(currentSession);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return null;\n            }\n        });\n    }\n    _callRefreshToken(refresh_token) {\n        var _a;\n        if (refresh_token === void 0) { refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token; }\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error)\n                    throw error;\n                if (!data)\n                    throw Error('Invalid session data.');\n                this._saveSession(data);\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    _notifyAllSubscribers(event) {\n        this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        this.currentSession = session;\n        this.currentUser = session.user;\n        const expiresAt = session.expires_at;\n        if (expiresAt) {\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = expiresAt - timeNow;\n            const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5;\n            this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n        }\n        // Do we need any extra check before persist session\n        // access_token or user ?\n        if (this.persistSession && session.expires_at) {\n            this._persistSession(this.currentSession);\n        }\n    }\n    _persistSession(currentSession) {\n        const data = { currentSession, expiresAt: currentSession.expires_at };\n        isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.currentSession = null;\n            this.currentUser = null;\n            if (this.refreshTokenTimer)\n                clearTimeout(this.refreshTokenTimer);\n            isBrowser() && (yield this.localStorage.removeItem(STORAGE_KEY));\n        });\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n    _startAutoRefreshToken(value) {\n        if (this.refreshTokenTimer)\n            clearTimeout(this.refreshTokenTimer);\n        if (value <= 0 || !this.autoRefreshToken)\n            return;\n        this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value);\n        if (typeof this.refreshTokenTimer.unref === 'function')\n            this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            // console.debug('Auth multi-tab support is disabled.')\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e) => {\n                var _a;\n                if (e.key === STORAGE_KEY) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                        this._recoverAndRefresh();\n                        this._notifyAllSubscribers('SIGNED_IN');\n                    }\n                    else {\n                        this._removeSession();\n                        this._notifyAllSubscribers('SIGNED_OUT');\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}